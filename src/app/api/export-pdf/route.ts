import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import jsPDF from 'jspdf';

/**
 * PDF Export API - Canva Optimized
 * 
 * This API generates PDFs optimized for copy-paste into Canva and other design tools:
 * - Clean ASCII-only text (no emojis or special characters)
 * - Normalized line endings and spacing
 * - Improved text boundaries for easy selection
 * - Better visual separation between sections
 * - Consistent formatting throughout
 * - Professional typography and margins
 */

interface ExportPDFRequest {
  courseId?: string;
  courseData?: unknown;
  includeWatermark?: boolean;
}

export async function POST(request: NextRequest) {
  try {
    console.log('ðŸš€ PDF Export API called');
    
    // Get user authentication from Supabase Auth
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      console.log('âŒ User not authenticated:', authError?.message);
      return NextResponse.json(
        { success: false, error: 'User not authenticated' },
        { status: 401 }
      );
    }

    // Get user profile from database
    const { data: profile, error: profileError } = await supabase
      .from('users')
      .select('*')
      .eq('id', user.id)
      .single();
      
    if (profileError || !profile) {
      console.log('âŒ User profile not found for:', user.id, profileError?.message);
      return NextResponse.json(
        { success: false, error: 'User profile not found' },
        { status: 404 }
      );
    }
    
    console.log('âœ… PDF Export - Auth status:', { 
      userId: user.id, 
      email: user.email,
      subscriptionStatus: profile.subscription_status 
    });
    
    let body: ExportPDFRequest;
    try {
      body = await request.json();
    } catch (parseError) {
      console.log('âŒ Failed to parse request body:', parseError);
      return NextResponse.json(
        { success: false, error: 'Invalid JSON in request body' },
        { status: 400 }
      );
    }
    
    const { courseId, courseData } = body;

    if (!courseData) {
      console.log('âŒ Course data missing from request');
      return NextResponse.json(
        { success: false, error: 'Course data is required' },
        { status: 400 }
      );
    }
    
    // Validate course data structure
    if (!courseData.title) {
      console.log('âŒ Course title missing');
      return NextResponse.json(
        { success: false, error: 'Course title is required' },
        { status: 400 }
      );
    }
    
    if (!Array.isArray(courseData.modules)) {
      console.log('âŒ Course modules invalid or missing');
      return NextResponse.json(
        { success: false, error: 'Course modules must be an array' },
        { status: 400 }
      );
    }
    
    console.log('ðŸ“Š Course data validated:', {
      title: courseData.title,
      modulesCount: courseData.modules.length,
      courseId: courseId
    });

    // All users can export PDF, but Pro users get custom branding and no watermark
    const isPro = profile.subscription_status === 'pro' || profile.subscription_status === 'lifetime';

    // Use course data directly with proper typing
    const course = courseData as any;

    // For now, use default branding (we can add custom branding later)
    const branding = {
      logo_url: null,
      primary_color: '#3B82F6', // Default blue
      footer_text: isPro ? 'Generated by TweetToCourse' : null
    };
    console.log('ðŸŽ¨ Branding settings:', { isPro, branding });

    // Generate clean, professional PDF inspired by business documents
    console.log('ðŸ“„ Starting clean, professional PDF generation');
    
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 25; // Slightly larger margins for professional look
    const maxWidth = pageWidth - (margin * 2);
    
    let yPosition = margin;
    
    console.log('ðŸ“ PDF dimensions:', {
      pageWidth,
      pageHeight,
      margin,
      maxWidth
    });

    // Helper function to check if we need a new page
    const checkPageBreak = (requiredSpace: number) => {
      if (yPosition + requiredSpace > pageHeight - 50) {
        pdf.addPage();
        yPosition = margin;
        return true;
      }
      return false;
    };

    // Helper function to add a text block with clear boundaries for Canva
    const addTextBlock = (text: string, fontSize: number = 11, isBold: boolean = false, spacingBefore: number = 5, spacingAfter: number = 10) => {
      if (!text || !text.trim()) return;
      
      // Add spacing before the text block
      yPosition += spacingBefore;
      
      // Add the text
      addText(text, fontSize, isBold, spacingAfter);
    };

    // Helper function to add clean text optimized for Canva copy-paste
    const addText = (text: string, fontSize: number = 11, isBold: boolean = false, spacingAfter: number = 8) => {
      if (!text || !text.trim()) return;
      
      // Canva-optimized text cleaning - preserve structure but remove problematic characters
      const cleanText = text
        .replace(/[^\x20-\x7E\n\r]/g, '') // Keep only printable ASCII + line breaks
        .replace(/\r\n/g, '\n') // Normalize line endings
        .replace(/\r/g, '\n') // Convert remaining \r to \n
        .replace(/\t/g, '    ') // Convert tabs to spaces
        .replace(/\s+/g, ' ') // Normalize whitespace but preserve single spaces
        .replace(/\n\s+/g, '\n') // Remove leading spaces after line breaks
        .replace(/\s+\n/g, '\n') // Remove trailing spaces before line breaks
        .trim();
      
      if (!cleanText) return;
      
      pdf.setFontSize(fontSize);
      pdf.setFont('helvetica', isBold ? 'bold' : 'normal');
      pdf.setTextColor(0, 0, 0);
      
      // Optimize line splitting for better copy-paste experience
      const lines = pdf.splitTextToSize(cleanText, maxWidth);
      const textHeight = lines.length * (fontSize * 0.35);
      
      checkPageBreak(textHeight + spacingAfter);
      
      // Add invisible text boundaries for better selection (using spaces)
      pdf.text(lines, margin, yPosition);
      yPosition += textHeight + spacingAfter;
    };

    // Helper function to add section with Canva-optimized spacing
    const addSection = (title: string, content: string = '', titleSize: number = 14) => {
      // Add extra space before sections for better visual separation
      yPosition += 8;
      
      // Section title with clear boundaries
      addText(title, titleSize, true, 14);
      
      // Section content with proper spacing
      if (content) {
        addText(content, 11, false, 16);
      }
    };

    // Helper function to add bullet point optimized for Canva copy-paste
    const addBulletPoint = (text: string, indent: number = 15) => {
      const cleanText = text
        .replace(/[^\x20-\x7E\n]/g, '') // Keep line breaks for better structure
        .replace(/^\s*[-â€¢*]\s*/, '') // Remove existing bullet markers
        .replace(/\s+/g, ' ') // Normalize spaces
        .trim();
      
      if (!cleanText) return;
      
      pdf.setFontSize(11);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(0, 0, 0);
      
      // Use simple bullet for better copy-paste compatibility
      pdf.text('â€¢', margin + 5, yPosition);
      
      // Add text with proper wrapping and spacing for easy selection
      const lines = pdf.splitTextToSize(cleanText, maxWidth - indent);
      const textHeight = lines.length * (11 * 0.35);
      
      checkPageBreak(textHeight + 8);
      
      pdf.text(lines, margin + indent, yPosition);
      yPosition += textHeight + 8; // Extra spacing for better visual separation
    };

    // Helper function to process content with Canva copy-paste optimization
    const processContent = (content: string) => {
      const lines = content.split('\n');
      
      for (const line of lines) {
        const cleanLine = line.trim();
        if (!cleanLine) {
          // Add small spacing for empty lines to maintain structure
          yPosition += 4;
          continue;
        }
        
        // Handle markdown headers with better spacing
        if (cleanLine.startsWith('###')) {
          const headerText = cleanLine.replace(/^#+\s*/, '');
          addSection(headerText, '', 12);
        } else if (cleanLine.startsWith('##')) {
          const headerText = cleanLine.replace(/^#+\s*/, '');
          addSection(headerText, '', 13);
        } else if (cleanLine.startsWith('#')) {
          const headerText = cleanLine.replace(/^#+\s*/, '');
          addSection(headerText, '', 14);
        }
        // Handle bold text as subsection headers
        else if (cleanLine.startsWith('**') && cleanLine.endsWith('**')) {
          const boldText = cleanLine.replace(/^\*\*|\*\*$/g, '');
          addText(boldText, 12, true, 12);
        }
        // Handle bullet points with improved formatting
        else if (cleanLine.match(/^\s*[-â€¢*]\s/)) {
          addBulletPoint(cleanLine);
        }
        // Handle numbered lists with consistent formatting
        else if (cleanLine.match(/^\d+\.\s/)) {
          const numberedText = cleanLine.replace(/^\d+\.\s*/, '');
          const number = cleanLine.match(/^\d+/)?.[0];
          addText(`${number}. ${numberedText}`, 11, false, 8);
        }
        // Handle regular paragraphs with clean formatting
        else {
          const paragraph = cleanLine
            .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markdown
            .replace(/\*(.*?)\*/g, '$1') // Remove italic markdown
            .replace(/`(.*?)`/g, '$1') // Remove code formatting
            .replace(/\[(.*?)\]\(.*?\)/g, '$1'); // Remove links, keep text
          
          addText(paragraph, 11, false, 12);
        }
      }
    };

    // Document title with clear spacing for easy selection
    addText(course.title, 18, true, 25);
    
    // Document info with separator line for visual clarity
    addText(`Generated: ${new Date().toLocaleDateString()}`, 9, false, 15);
    
    // Add a visual separator for better content organization
    yPosition += 10;

    // Course overview section with improved formatting for Canva
    const modules = Array.isArray(course.modules) ? course.modules : [];
    const totalReadTime = modules.reduce((total: number, module: any) => total + (module.estimatedReadTime || 8), 0);
    const totalTakeaways = modules.reduce((total: number, module: any) => total + (module.takeaways?.length || 0), 0);
    
    addSection('COURSE OVERVIEW');
    addText(`Modules: ${modules.length}`, 11, false, 8);
    addText(`Reading Time: ${totalReadTime} minutes`, 11, false, 8);
    addText(`Key Points: ${totalTakeaways}`, 11, false, 25);

    // Process each module with Canva-optimized formatting
    modules.forEach((module: any, index: number) => {
      // Module header with clear separation
      addSection(`MODULE ${index + 1}: ${module.title.toUpperCase()}`, '', 15);
      
      // Module info with clean formatting
      const readTime = module.estimatedReadTime || 8;
      const takeawayCount = module.takeaways?.length || 0;
      addText(`Reading Time: ${readTime} minutes | Key Points: ${takeawayCount}`, 10, false, 18);
      
      // Process module content with better structure
      if (module.summary) {
        console.log(`Processing module ${index + 1} content (${module.summary.length} chars)`);
        processContent(module.summary);
        yPosition += 10; // Extra space after content
      }
      
      // Add takeaways with improved formatting for Canva copy-paste
      if (module.takeaways && Array.isArray(module.takeaways) && module.takeaways.length > 0) {
        addSection('KEY TAKEAWAYS', '', 13);
        
        module.takeaways.forEach((takeaway: string, idx: number) => {
          const cleanTakeaway = takeaway
            .replace(/[^\x20-\x7E\n]/g, '') // Keep line breaks
            .replace(/^\s*[-â€¢*]\s*/, '') // Remove bullet markers
            .replace(/\s+/g, ' ') // Normalize spaces
            .replace(/\s+$/, '') // Remove trailing spaces
            .trim();
          
          if (cleanTakeaway) {
            // Add each takeaway as a separate text block for easier selection
            addTextBlock(`${idx + 1}. ${cleanTakeaway}`, 11, false, 2, 8);
          }
        });
        
        yPosition += 20; // Extra space after takeaways for module separation
      }
    });

    // Add clean, professional footer
    const totalPages = pdf.getNumberOfPages();
    console.log('ðŸ“„ Adding clean footer to', totalPages, 'pages. isPro:', isPro);
    
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      
      // Clean footer line
      pdf.setDrawColor(220, 220, 220);
      pdf.line(margin, pageHeight - 30, pageWidth - margin, pageHeight - 30);
      
      // Page number (right aligned)
      pdf.setFontSize(9);
      pdf.setTextColor(120, 120, 120);
      pdf.text(`${i}`, pageWidth - margin, pageHeight - 20, { align: 'right' });
      
      // Company name (left aligned, only for free users)
      if (!isPro) {
        pdf.setFontSize(9);
        pdf.setTextColor(120, 120, 120);
        pdf.text('TweetToCourse', margin, pageHeight - 20);
      }
    }

    // Log the export action
    try {
      await supabase
        .from('usage_logs')
        .insert({
          user_id: user.id,
          action: 'export_pdf',
          metadata: {
            course_id: courseData.id || 'unknown',
            course_title: courseData.title
          }
        });
      console.log('âœ… PDF export logged successfully');
    } catch (logError) {
      console.error('âš ï¸ Failed to log PDF export:', logError);
      // Don't fail the PDF generation for logging errors
    }

    // Generate PDF buffer
    console.log('ðŸ“¦ Generating PDF buffer...');
    
    let pdfBuffer: Buffer;
    try {
      const pdfOutput = pdf.output('arraybuffer');
      pdfBuffer = Buffer.from(pdfOutput);
      
      console.log('âœ… PDF buffer generated successfully:', {
        size: pdfBuffer.length,
        sizeKB: Math.round(pdfBuffer.length / 1024),
        sizeMB: Math.round(pdfBuffer.length / (1024 * 1024) * 100) / 100
      });
      
      if (pdfBuffer.length === 0) {
        throw new Error('Generated PDF buffer is empty');
      }
      
    } catch (bufferError) {
      console.error('âŒ Failed to generate PDF buffer:', bufferError);
      return NextResponse.json(
        { 
          success: false, 
          error: 'Failed to generate PDF buffer',
          details: bufferError instanceof Error ? bufferError.message : 'Unknown buffer error'
        },
        { status: 500 }
      );
    }

    // Create safe filename
    const filename = `${course.title.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '_')}_course.pdf`;
    
    console.log('ðŸ“¤ Returning PDF download:', {
      filename,
      bufferSize: pdfBuffer.length,
      contentType: 'application/pdf'
    });
    
    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': pdfBuffer.length.toString(),
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      },
    });

  } catch (error) {
    console.error('PDF export error:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to export PDF',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

export async function GET() {
  return NextResponse.json(
    { success: false, error: 'GET method not supported' },
    { status: 405 }
  );
}