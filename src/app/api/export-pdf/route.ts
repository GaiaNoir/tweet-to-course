import { NextRequest, NextResponse } from 'next/server';
import { getCurrentUser, canPerformAction, incrementUsage } from '@/lib/auth';
import { getUserBranding } from '@/lib/branding-utils';
import jsPDF from 'jspdf';

interface ExportPDFRequest {
  courseId?: string;
  courseData?: any;
  includeWatermark?: boolean;
}

export async function POST(request: NextRequest) {
  try {
    const user = getCurrentUser();
    
    if (!user) {
      return NextResponse.json(
        { success: false, error: 'User not found' },
        { status: 401 }
      );
    }
    
    // For debugging - log the auth status
    console.log('PDF Export - Auth status:', { userId: user.id });
    
    const body: ExportPDFRequest = await request.json();
    const { courseId, courseData } = body;

    if (!courseData) {
      return NextResponse.json(
        { success: false, error: 'Course data is required' },
        { status: 400 }
      );
    }

    // Check if user can export PDF
    if (!canPerformAction('export_pdf')) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'PDF export not available for your subscription tier',
          upgradeRequired: true
        },
        { status: 403 }
      );
    }

    // Use course data directly
    const course = courseData;

    // Get user branding settings
    const branding = await getUserBranding(user.id);
    const isPro = canPerformAction('remove_watermark');

    // Generate PDF
    const pdf = new jsPDF();
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const maxWidth = pageWidth - (margin * 2);
    
    let yPosition = margin;

    // Add logo if available and user is Pro
    if (isPro && branding.logo_url) {
      try {
        // Note: In a real implementation, you'd need to fetch and embed the image
        // For now, we'll just add a placeholder text
        pdf.setFontSize(10);
        pdf.setTextColor(100, 100, 100);
        pdf.text('Logo: ' + branding.logo_url.split('/').pop(), margin, yPosition);
        yPosition += 15;
      } catch (error) {
        console.error('Error adding logo to PDF:', error);
      }
    }

    // Helper function to add text with word wrapping and custom colors
    const addText = (text: string, fontSize: number = 12, isBold: boolean = false, useCustomColor: boolean = false) => {
      pdf.setFontSize(fontSize);
      pdf.setFont('helvetica', isBold ? 'bold' : 'normal');
      
      // Apply custom colors for Pro users
      if (isPro && useCustomColor && branding.primary_color) {
        const color = branding.primary_color;
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        pdf.setTextColor(r, g, b);
      } else {
        pdf.setTextColor(0, 0, 0); // Default black
      }
      
      const lines = pdf.splitTextToSize(text, maxWidth);
      
      // Check if we need a new page
      if (yPosition + (lines.length * fontSize * 0.5) > pageHeight - margin) {
        pdf.addPage();
        yPosition = margin;
      }
      
      pdf.text(lines, margin, yPosition);
      yPosition += lines.length * fontSize * 0.5 + 5;
    };

    // Add title with custom color
    addText(course.title, 20, true, true);
    yPosition += 10;

    // Add generation date
    addText(`Generated on: ${new Date().toLocaleDateString()}`, 10);
    yPosition += 15;

    // Add modules
    const modules = Array.isArray(course.modules) ? course.modules : [];
    
    modules.forEach((module: any, index: number) => {
      // Module title with custom color
      addText(`Module ${index + 1}: ${module.title}`, 16, true, true);
      yPosition += 5;
      
      // Module summary
      if (module.summary) {
        addText(module.summary, 12);
        yPosition += 10;
      }
      
      // Takeaways
      if (module.takeaways && Array.isArray(module.takeaways)) {
        addText('Key Takeaways:', 14, true, true);
        yPosition += 5;
        
        module.takeaways.forEach((takeaway: string) => {
          addText(`â€¢ ${takeaway}`, 12);
        });
        yPosition += 15;
      }
    });

    // Add footer to each page
    const totalPages = pdf.getNumberOfPages();
    
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(10);
      pdf.setTextColor(150, 150, 150);
      
      if (isPro) {
        // Use custom footer text for Pro users
        const footerText = branding.footer_text || 'Generated by TweetToCourse';
        pdf.text(footerText, pageWidth / 2, pageHeight - 10, { align: 'center' });
      } else {
        // Add watermark for free users
        pdf.text('Generated by TweetToCourse - Upgrade to remove watermark', 
          pageWidth / 2, pageHeight - 10, { align: 'center' });
      }
    }

    // Log the export action
    incrementUsage();

    // Generate PDF buffer
    const pdfBuffer = Buffer.from(pdf.output('arraybuffer'));

    // Return PDF as download
    const filename = `${course.title.replace(/[^a-zA-Z0-9]/g, '_')}_course.pdf`;
    
    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': pdfBuffer.length.toString(),
      },
    });

  } catch (error) {
    console.error('PDF export error:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to export PDF',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

export async function GET() {
  return NextResponse.json(
    { success: false, error: 'GET method not supported' },
    { status: 405 }
  );
}